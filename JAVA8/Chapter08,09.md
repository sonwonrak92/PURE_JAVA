# 리팩토링

## 익명 클래스를 람다 표현식으로 리팩토링

- 익명 클래스에서 사용한 this와 super는 람다 표현식에서 다른 의미를 갖는다. 익명 클래스에서는 this는 익명 클래스 자신을 가리키지만 람다에서 this는 람다를 감싸는 클래스를 가리킨다.

- #### 장점 -  코드가 간결해진다.

  ```java
  //익명 클래스
  Runaable r1 = new Runnable(0 {
      public void run() {
          Syso("hello");
      }
  })
      
  //람다 표현식    
  Runaable r1 = ( ) -> Syso("hello");  
  ```

- #### 단점 - 메서드 호출시 대상 형식에 대한 모호함 발생

  ```java
  doSomething(( )->syso("")); // doSomething(Runnable) or doSomething(Task t)
  
  //doSomething의 어떤 메소드에 대한 대상 형식의 모호함
  ```


## 람다 표현식을 메서드 레퍼런스로 리팩토링

- #### 장점 - 메서드 레퍼런스의 메서드명으로 코드의 의도를 명확하게 알릴 수 있다

  ```java
  //람다표현식
  inven.sort(
      (a1, a2) -> a1.getWeight().compareTo(a2.getWeight())
   );
  
  //메서드 레퍼런스
  inven.sort( comparing(A::getWeight) );
      
  ```


## 명령형 데이터 처리를 스트림으로 리팩토링

- for문을 이용한 데이터 처리에 비해 stream으로 데이터처리를 하면 가독성은 좋을지라도 성능면에서 장담할 수 없다.



# 다양한 객체지향 디자인 패턴

## 전략패턴

- 알고리즘을 나타내는 인터페이스
- 다양한 알고리즘을 나타내는 한 개 이상의 인터페이스 구현
- 전략 객체를 사용하는 한 개 이상의 클라이언트

## 템플릿 메서드

- 알고리즘의 개요를 제시한 다음에 알고리즘의 일부를 고칠 수 있는 유연함을 제공해야할 때 사용하는 디자인 패턴

## 옵저버 패턴

- 어떤 이벤트가 발생했을 때 한 객체가 다른 객체 리스트에 자동으로 알림을 보내야하는 상황에서 사용하는 패턴

## 의무체인

- 작업처리 객체의 체인을 만들 때 사용. 한 객체가 어떤 작업을 처리한 다음에 다른 객체로 결과를 전달하고, 다른 객체도 해야 할 작업을 다음에 또 다른 객체에 전달하는 식.

## 팩토리

- 인스턴스화 로직을 클라이언트에 노출하지 않고 객체를 만들 때 사용한다.



------



# 디폴트 메서드

- 자바 8에서는 구편 코드를 포함하는 디폴트 메서드와 정적 메서드를 정의할 수 있다.
- 공개된 인터페이스에 추상 메서드를 추가하면 소스의 호환성이 깨지기 때문에 디폴트 메서드를 추가하여 호환성을 제공해야 한다.
- 클래스나 슈퍼클래스에 정의된 메서드가 다른 디폴트 메서드 정의보다 우선한다.
- 두 메서드의 시그너처가 같고 상속관계로도 충돌 문제가 해결되지 않으면 디폴트 메서드를 사용하는 클래스에서 메서드를 오버라이드해서 어떤 디폴트 메서드를 호출할지 **명시적으로 결정**해야한다.