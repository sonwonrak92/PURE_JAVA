# 람다

> 람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화한 것이다.
>
> 람다를 이용하면 간결한 방식으로 코드를 전달할 수 있다.

```java
(Apple a1, Appple a2)    ->     a1.getWeight().compareTo(a2.getWeight());
    //람다표현식		  //화살표      //람다의 바디    	
```

- **람다표현식** : 메서드의에서 사용할 파라미터를 입력하는 부분
- **화살표** : 파라미터와 바디를 구분하는 역할
- **람다의** 바디 : 람다의 반환값에 해당하는 표현식을 입력하는 부분 (메소드 구현부분)



### 유효한 람다 표현식

```java
1. (String s) -> s.length()  //String 파라미터에 int값 반환
2. (Apple a) -> a.getWeight() > 150 //Apple 객체 파라미터에 boolean값 반환
3. (int x, int y)  -> {  //2개의 int 파라미터에 void 리턴
        syso("result : ");
        syso(x+y);
	}
4 .() -> 42 //파라미터가 없고 int값 반환
    
```

### 잘못된 람다 표현식

```java
1. (Integer i) -> return "alan" + i ; //{}가 없음.
2. (Integer i) -> {"Iron man";} //구문이 아닌 표현식이 들어가있음 {} 제거필요
```



### 함수형 인터페이스

> 함수형 인터페이스란? 하나의 추상 메서드를 지정하는 인터페이스다. 많은 디폴트 메소드가 존재하더라도 추상 메서드가 오직 하나면 함수형 인터페이스라고 할 수 있다.

- 함수형 인터페이스 내부에 존재하는 추상 메서드 시그너처의 서술 부분을 **함수 디스크립터**라고 부른다.
- 함수형 인터페이스에는 **@FunctionalInterface**라는 어노테이션을 사용한다.



> !! 제네릭 파라미터에는 참조형만 사용할 수 있다. 따라서 제네릭 파라미터 사용을 위해 기본형을 참조형으로 변환하는 박싱이 필요하며 반대 동작을 언박싱이라고한다.



### 형식검사

- 람다가 사용되는 콘텍스트를 이용해서 람다의 형식을 추론할 수 있는데, 어떤 콘텍스트에서 기대되는 람다 표현식의 형식을 **대상 형식**이라고 부른다.

> 형식검사 순서는
>
> 1.메서드의 선언을 확인한 후 
>
> 2.메서드의 파라미터인 대상 형식을 기대한다.
>
> 3.대상형식이 함수형 인터페이스일 경우에는 해당 함수 디스크립터를 묘사한다.
>
> 5.함수 디스크립터에서 요청하는 파라미터와 리턴값이 일치할 경우 유효한 코드로 판단한다.



### 형식추론

- 자바 컴파일러는 람다 표현식이 사용된 콘텍스트를 이용해서 람다 표현식과 관련된 함수형 인터페이스를 추론한다.


### 람다에서 지역 변수 사용

> 지역 변수는 명시적으로 final로 선언되어 있어야 하거나 실질적으로 final로 선언된 변수처럼 사용되어야 한다.

```java
int portNumber = 1234;
Runnable r = () -> syso(portNumber); //지역변수인 portNumber를 사용하지만 에러남. 
portNumber = 31335; // <--값을 두번 할당할 경우 final이 아니기에 컴파일 에러
```

- 이유는 인스터스 변수는 힙에 저장되는 반면 지역 변수는 스택에 위치한다.



# 메서드 레퍼런스

> 메서드 레퍼런스란? 특정 메서드만을 호출하는 람다의 축약형이라고 생각할 수 있다.
>
> 명시적으로 메서드명을 참조함으로써 가독성을 높일 수 있다.

### 

### 메서드 레퍼런스 만드는 방법

- 정적 메서드 레퍼런스 

  ```java
  Interger::parseInt
  ```

- 다양한 형식의 인스턴스 메서드 레퍼런스

  ```java
  String::length
  ```

- 기존 객체의 인스턴스 메서드 레퍼런스

  ```java
  Transaction t = new Transaction();
  t::getValue
  ```
